package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.*
import java.net.URI
import kotlinx.android.synthetic.main.*


class Snippets(context: Context) {

    private val TAG = "MainActivity"

    fun testGettingStarted() {
        // tag::getting-started[]
        // Get the database (and create it if it doesnâ€™t exist).
        val config = DatabaseConfiguration(context)
        val database = Database("mydb", config)

        // Create a new document (i.e. a record) in the database.
        var mutableDoc: MutableDocument = MutableDocument()
            .setFloat("version", 2.0F)
            .setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = (database.getDocument(mutableDoc.id)).toMutable() as MutableDocument
        mutableDoc.setString("language", "Java")
        database.save(mutableDoc)
        val document = database.getDocument(mutableDoc.id)

        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: " + document.id)
        Log.i(TAG, "Learning " + document.getString("language"))

        // Create a query to fetch documents of type SDK.
        val query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
        val result: ResultSet = query.execute()
        Log.i(TAG, "Number of rows ::  " + result.allResults().size) // REPLACED .size() with count()

        // Create replicators to push and pull changes to and from the cloud.
        val targetEndpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/example_sg_db"))

        var replConfig = ReplicatorConfiguration(database, targetEndpoint)
        replConfig.replicatorType = ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL

        // Add authentication.
        replConfig.authenticator = BasicAuthenticator("john", "pass")
        // replConfig.setAuthenticator(BasicAuthenticator("john", "pass"))

        // Create replicator.
        val replicator = Replicator(replConfig)
        // LOG TEST added:
        Log.i(TAG, "replicator before change is like: " + replicator.toString())
		
		class ReplicatorChangeListenerAdapter: ReplicatorChangeListener{
			override fun changed(change: ReplicatorChange){
				if(change.status.error != null)
					Log.i(TAG, "Error code :: " + change.status.error.code)
			}
		}
		replicator.addChangeListener(ReplicatorChangeListenerAdapter())
		
		// Start replication
		replicator.start()
//        replicator.stop()
		
        // end::getting-started[]
        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", applicationContext.filesDir)

        ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), getApplicationContext().getFilesDir())

        val db = Database("android-sqlite", DatabaseConfiguration(getApplicationContext()))
        try {

            val doc = db.getDocument("doc1")

            // For Validation
            val attachments = doc.getDictionary("_attachments")
            val blob = attachments.getBlob("attach1")
            val content = blob.getContent()
            // For Validation

            val attach = String.format(Locale.ENGLISH, "attach1").toByteArray()
            Arrays.equals(attach, content)

        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", getApplicationContext().getFilesDir())
        }

        val document = MutableDocument()

        // tag::1x-attachment[]
        val attachments = document.getDictionary("_attachments")
        val blob = if (attachments != null) attachments!!.getBlob("avatar") else null
        val content = if (blob != null) blob!!.getContent() else null
        // end::1x-attachment[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val config = DatabaseConfiguration(applicationContext)
        val database = Database("my-database", config)
        // end::new-database[]

        database.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val config = DatabaseConfiguration(applicationContext);
        config.encryptionKey = EncryptionKey("PASSWORD");
        val database = Database("mydb", config);
        // end::database-encryption[]
    }

    // ### Logging
    @Throws(CouchbaseLiteException::class)
    fun testLogging() {
        // tag::logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
        Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
        // end::logging[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract it from your
        // assets to a temporary directory and then pass that path to Database.copy()
        val context = applicationContext
        val configuration = DatabaseConfiguration(context)
        if (!Database.exists("travel-sample", context.filesDir)) {
            ZipUtils.unzip(assets.open("travel-sample.cblite2.zip"), applicationContext.filesDir)
            val path = File(applicationContext.filesDir, "travel-sample")
            try {
                Database.copy(path, "travel-sample", configuration)
            } catch (e: CouchbaseLiteException) {
                e.printStackTrace()
            }

        }
        // end::prebuilt-database[]
    }

    // helper methods

    // if db exist, delete it
    @Throws(CouchbaseLiteException::class)
    private fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (i in 0..9) {
                try {
                    Database.delete(name, dir)
                    break
                } catch (ex: CouchbaseLiteException) {
                    if (ex.code === CBLErrorBusy) {
                        try {
                            Thread.sleep(300)
                        } catch (e: Exception) {
                        }

                    } else {
                        throw ex
                    }
                }

            }
        }
    }


}